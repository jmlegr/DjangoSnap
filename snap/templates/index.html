<!DOCTYPE html>
<meta charset="utf-8">
<style>
.node rect {
	cursor: pointer;
	fill: #fff;
	/*fill-opacity: 0.5;*/
	stroke: #3182bd;
	stroke-width: 1.5px;
}

.node text {
	font: 8px sans-serif;
	pointer-events: none;
}

.link {
	fill: none;
	stroke: green;
	stroke-width: 1.5px;
	opacity: 0.2;
}

.autreslink {
	fill: none;
	stroke: red;
	stroke-width: 1.5px;
}
.nextblock {
    fill: none;
    stroke: blue;
    stroke-width: 1.5px;
}
.changed {
    fill: none;
    stroke: red;
    stroke-width: 1.5px;
}
.moved {
    fill: none;
    stroke: green;
    stroke-width: 1.5px;
    stroke-dasharray: 5,10,5;
}
.replaced {
    fill: none;
    stroke: pink;
    stroke-width: 1.5px;
    /*stroke-dasharray: 5,10,5;*/
}
body {
	margin: 0;
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
}

.graph-svg-component {
	background-color: AliceBlue;
	
}

.tree1 {
	/* background-color: AliceBlue; marche pas sur <g>, seulement sur ses enfants*/
	fill: red;
}
/* voir https://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js#25978286*/
.svg-container {
    display: inline-block;
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* aspect ratio */
    vertical-align: top;
    overflow: hidden;
}
.svg-content-responsive {
    display: inline-block;
    position: absolute;
    top: 10px;
    left: 0;
}
#liste {
    height: 100px;
    width: 100%;
    border:2px solid #000;
    overflow-y: scroll;
    overflow-x: hidden;
}
.action rect {
    opacity: 0.5;
}
.action.SPR rect {
    fill: red;
    } 
.action.ENV rect {
    fill: blue;
    }
.action text {
font: 8px sans-serif;
    pointer-events: none;
}
</style>
<body>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>
	Set.prototype.union = function(setB) {
	    var union = new Set(this);
	    for (var elem of setB) {
	        union.add(elem);
	    }
	    return union;
	}
var donnees=[], root1={},ticks=[]

function getPrevNode(node) {
    //renvoie le noeud temporellement précédent, s'il existe
    if (node.data.time>0) {
	   n=root1.descendants()
	       .filter(function(d) {return d.data.JMLid==node.data.JMLid && d.data.time<node.data.time;})
	       .sort(function(a,b) {return a.data.time-b.data.time})
	       .pop()
	    return n	   
    }
    return undefined    
}

function getLastParentId(node){
    //renvoie l'id du noeud parent s'il existe, 
    //ou l'id du noeud parent temporellement précédent s'il existe
    // ou l'id de la racine
    nodeId=node.conteneurBlock==null?node.parentBlock:node.conteneurBlock
    if (nodeId!=null) {
	    n=donnees
	      .filter(function(d) {return d.time<=node.time && (d.id==nodeId || d.JMLid==nodeId.split('_',1)[0])})
          .sort(function(a,b) {return a.time-b.time})
          .pop()
        return n==undefined?'racine':n.id
    }
    return null
}
function getJson() {
    d3.json("tb",function(error,data) {
    if (error) {
	    console.warn("error",error.type,":",error.target.statusText)
	    return   
    }
    //console.log("rec",data.inputs.filter(function(d) {return d.time==0 }))
	/*donnees={name:data.name,
		    inputs:data.inputs.filter(function(d) {return d.time==0 })
	}*/
	/*
	preparation des donnees: 
	    tous les blocks au temps 0,
	    avec ajout d'une racine fictive
	    ajouts des blocks contenus en enfant des blocks contenant
	*/
	//donnees=data.inputs.filter(function(d) {return d.time==0 })
	donnees=data.data
	donnees.filter(function(d) {return d.parentBlock==null && d.conteneurBlock==null})
	   .forEach(function(d) {d.parentBlock='racine'})
	ticks=data.ticks
	racine={name:"racine",id:"racine",time:-1,rang:null,inputs:donnees.filter(function(d) {return d.parentBlock=='racine'})}
	//root1=d3.hierarchy(donnees,function children(d) {return d.inputs;})
	donnees.push(racine)
	console.log(donnees)
	root1=d3.stratify()
	       .parentId(function(d) {		        
		        parentId=getLastParentId(d);		        
		        return parentId
		    })
	       (donnees)
	root1.x0 = 0;
    root1.y0 = 0;
    //calcul des coordonnées et ajout éventuel des liens avec le prevNode
    root1._autresLinks=data.links
    var index = -1;
    var last=null
    /*
    root1.sort(function(a,b) {return a.data.time-b.data.time || a.data.rang-b.data.rang})
        .eachAfter(function(n) {
            n.JMLids=new Set([n.data.JMLid])
            if (n.height>0){            
        	 n.children.forEach(function(d) {n.JMLids=n.JMLids.union(d.JMLids)})
            }        	   
        })
    */
    root1.sort(function(a,b) {return a.data.time-b.data.time || a.data.rang-b.data.rang})       
       .eachBefore(function(n) {
	    n.last=last
	    last=n
	    //if (!n.dragged) {
	    //calcul des coordonnées
	    p=getPrevNode(n)	      
	    if (n.data.lastModifBlock==null && p==undefined ) {
	          n.x = ++index * barHeight ;       
	    } else if (n.data.lastModifBlock==null && p!=undefined) {
		   if (n.parent.data.time==n.data.time) n.x=n.last.x+barHeight;
		   else n.x=n.parent.x+(n.data.rang+1)*barHeight;		  
	    } else if (n.data.lastModifBlock!=null) {	     
		   n.x=root1.descendants().filter(function(d) {return d.id==n.data.lastModifBlock})[0].x
		} 
	    n.y = n.depth * 20 +ticks.indexOf(n.data.time)*120;
	    });
    
    root1.autresLinks=function() {
	   //renvoie les liens entre prevNode et Node, s'ils sont visibles
	    var edges=[];
	    for (i in this._autresLinks) {
	    e=this._autresLinks[i];
	     var sourceNode = this.descendants().filter(function(n) { 
		    return n.id === e.source; })[0],
	       targetNode = this.descendants().filter(function(n) { return n.id === e.target; })[0];
	     if (sourceNode!=undefined && targetNode!=undefined){
		  // Add the edge to the array	     
	      edges.push({source: sourceNode, target: targetNode, type:e.type});
	     }
	    }
	    //console.log('edges',edges)
	    return edges;
    }
	update(root1,root1)	
	
	updateListe(data.actions)
	})
}

function updateListe(actions) {
    //affiche la liste des étapes
    /*
    liste//.attr("viewBox", "0,0,900,420")
         .append("circle")
                                      .attr("cx", 25)
                                      .attr("cy", 25)
                                      .attr("r", 25)
                                      .style("fill", "purple");*/
    var min=d3.min(actions, function(d) { return d.evenement.numero})-1;
    console.log('min',min)
    /*l=liste.selectAll("text").data(actions,function(d) {return d.time})
    .enter()
    .append("text").text(function(d){return "temps"+d.evenement.time+':'+d.type_display})
    .attr("transform", function(d) { return "translate(" + 20 + "," + (d.evenement.numero-min)*30 + ")"; })
    */
    var rectHeight=25, padding=1
    var action=liste.selectAll(".action")
          .data(actions)
    var actionEnter=action.enter().append("g")
        .attr("class", function(d) {return "action "+d.evenement.type})
        .attr("transform", function(d) { 
            return "translate(" 
        	    + 20 + "," 
        	    + (d.evenement.numero-min)*(rectHeight+padding) 
        	    + ")"; 
            })        
      .style("opacity", 1)
    rect=actionEnter.append("rect")
        .attr("y", -rectHeight / 2)
        .attr("width",0)
        .attr("height", rectHeight)
        
    actionEnter.append("text")
       .attr("class","actiontext")
      .attr("dy", 3.5)
      .attr("dx", 5.5)
      .text(function(d) { return d.evenement.time+':'+d.type_display})
     //obligé de mettre le calcul de la largeur après la création
      rect.transition().duration(500)
        .attr('width', function (d, i) {
            console.log('zv',d3.selectAll('.actiontext'))
            return d3.selectAll('.actiontext').filter(function (d, j) { 
            return i === j; })
        .node().getComputedTextLength()+40; //20 de décalage texte à droite
         })
}

var margin = {top: 20, right: 20, bottom: 20, left: 20},
    width = "100%",
    height = "80%"
    barHeight = 12,
    //barWidth = (width - margin.left - margin.right) * 0.8;
    barWidth=100;

var i = 0,
    duration = function(dragged) {
     return dragged?0:500
},
    root;

var diagonal = d3.linkHorizontal()
    .x(function(d) { return d.y; })
    .y(function(d) { return d.x; });

//Define Zoom Function Event Listener
function zoomFunction() {
    var transform = d3.zoomTransform(this);
    console.log(this)
    //d3.select("#treesSvg")
    if (this.id=="#treesSvg")	
	    d3.select(this)
    //.transition().duration(500)
        .attr("transform", "translate(" 
	    + (transform.x+0) + "," + (transform.y+0) 
	    + ") "
	    + "scale(" + transform.k + ")");
    else 
	   d3.select(this)
	    //.transition().duration(500)
	        .attr("transform", "scale(" + transform.k + ")");
}

// Define Zoom Behavior
var zoom = d3.zoom()
        .scaleExtent([0.1, 20])
        .wheelDelta(function() {return -d3.event.deltaY * 10/500;})
        .on("zoom", zoomFunction);
var drag=d3.drag()
var svg = d3.select("body").append("svg")    
    .attr("preserveAspectRatio", "xMinYMin meet")
   .attr("viewBox", "0 0 600 400")
   //class to make it responsive
   .classed("svg-content-responsive", true)
    .attr("width", width) // + margin.left + margin.right)
    .attr("height",height)  
    .attr("class", "graph-svg-component")

    svg.call(zoom)    
    //.call(d3.zoom()
    //.on("zoom", function () {svg.attr("transform", d3.event.transform)})
    .on("dblclick.zoom", function() {
	   console.log("dezoom");
	    //svg.attr("transform", "translate(" + margin.left + "," + margin.top + ") scale(1)");
        svg.call(zoom.transform, d3.zoomIdentity);
    })

 svg=svg.append("g").attr("id","treesSvg"); 

var tree1=svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("class","tree1")

var liste=d3.select("body").append("div").attr("id","liste")            
            .append("svg")
            .attr("width","100%")
            .call(zoom);
   



getJson()

/*
root1._autresLinks=[{"source":2,"target":8},
    {"source":3,"target":12}]

};
*/


function draggedNode(d){
    //console.log("drag",d.x,d.y,d3.event.x,d3.event.y)
  //d3.select(this).attr("x", d.x=d3.event.x).attr("y", d.y=d3.event.y);
    d.x0=d.x=d3.event.y
    d.y0=d.y=d3.event.x
    d.dragged=true
    ancestors=d.ancestors()    
    update(d,ancestors[ancestors.length-1],true);
    updateLinks(true);
}
function update(source,root,dragged=false) {   
  // Compute the flattened node list.
  var nodes = root.descendants();

  //var height = Math.max(500, nodes.length * barHeight + margin.top + margin.bottom);
  //var height=1000;
  d3.select("svg").transition()
      .duration(duration(dragged))
      //.attr("height", height);
      //.attr("height", "100%");

  d3.select(self.frameElement).transition()
      .duration(duration(dragged))
      //.style("height", height + "px");
      //.style("height","100%")
  
  // Compute the "layout". TODO https://github.com/d3/d3-hierarchy/issues/67
  

  // Update the nodes…
  if (root==root1) tree=tree1
  else tree=tree2;
  
  
  var node = tree.selectAll(".node")
    .data(nodes, function(d) { return d.id || (d.id = ++i); })
    

  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .style("opacity", 0)
  //.call(d3.drag().on("drag",draggedNode))
      
  var test=function(d) {
      //console.info('test',d)
  };
  // Enter any new nodes at the parent's previous position.
  nodeEnter.append("rect")
        //.attr("x",function(d) {console.log('rect',d); return 12;})
      .attr("y", -barHeight / 2)
      .attr("height", barHeight)
      .attr("width", barWidth)
      .style("fill", color)
      .style("opacity",opacity)
      .on("click", click)
      .call(test)
      //.call(d3.drag().on("drag",dragged));;

  nodeEnter.append("text")
      .attr("dy", 3.5)
      .attr("dx", 5.5)
      .text(function(d) { return d.data.name; });

  // Transition nodes to their new position.
  nodeEnter.transition()
      .duration(duration(dragged))
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
      .style("opacity", 1);

  node.transition()
      .duration(duration(dragged))   
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
      .style("opacity", 1)
    .select("rect")
      .style("fill", color)
      .style("opacity",opacity)
  
  // Transition exiting nodes to the parent's new position.
  node.exit().transition()
      .duration(duration(dragged))
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .style("opacity", 0)
      .remove();

  // Update the links…
  var link = tree.selectAll(".link")
    .data(root.links(), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .on("click",function(e){
	   console.log('source:',e.source.id,' target:',e.target.id,e)})    
    .transition()
      .duration(duration(dragged))
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration(dragged))
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration(dragged))
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();
  var lines=svg.selectAll('.autreslink')
        .data(root1.autresLinks(),function(d) { return d.target.id; }) 
  function xpos(d) {
      return d.type=='nextblock'?d.source.y:(d.source.y+barWidth)
  }
  function ypos(d) {
      return {debut:d.type=='nextblock'?(d.source.x-barHeight/2):d.source.x,
	       fin:d.type=='nextblock'?(d.target.x+barHeight/2):d.target.x,
      }
  }
  lines.enter()
        .append('line')
        .attr("class", function(d) { return "autreslink "+d.type})
        .attr('x1',xpos)
        .attr('y1',function(d){return ypos(d).debut})        
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")        
        .style("opacity",0)
        .transition().duration(duration(dragged))
        .attr('x2',function(d){return d.target.y })
        .attr('y2',function(d){return ypos(d).fin})
        .style("opacity",01)
        
  lines.transition().duration(duration(dragged)*2)
    .attr('x1',xpos)
    .attr('y1',function(d){return d.source.x})
    .attr('x2',function(d){return d.target.y})
    .attr('y2',function(d){return d.target.x})
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .style("opacity",1)
 
  lines.exit() 
 //.attr('x1',function(d){return 0})
 //.attr('y1',function(d){return 0})
 //.attr('x2',function(d){return 0 })
 //.attr('y2',function(d){return 0})
    .style("opacity",function(d) {return 0})
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .transition().duration(duration(dragged))
    .remove;
  
  // Stash the old positions for transition.
  root.each(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}


// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  ancestors=d.ancestors()
  update(d,ancestors[ancestors.length-1]); 
  console.log('click sur',d.id,d)
}

function opacity(d) {
    return d._children ? 1 : d.children ? 0.6:0.6;
}
function color(d) {
  //
  switch (d.data.typeMorph) {
  case "InputSlotMorph": return  "#fd8d3c";
  case "ReporterBlockMorph": return "green";
  case "CSlotMorph": return "#3182bd";
  case "CommandBlockMorph": return "#c6dbef";
  default: return "pink";
  }
}

</script>